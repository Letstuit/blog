<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://openml.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://openml.github.io/blog/" rel="alternate" type="text/html" /><updated>2020-04-20T16:09:43-05:00</updated><id>https://openml.github.io/blog/feed.xml</id><title type="html">OpenML Blog</title><subtitle>A blog about OpenML and open machine learning in general.</subtitle><entry><title type="html">Finding a standard dataset format for machine learning</title><link href="https://openml.github.io/blog/openml/data/2020/03/23/Finding-a-standard-dataset-format-for-machine-learning.html" rel="alternate" type="text/html" title="Finding a standard dataset format for machine learning" /><published>2020-03-23T00:00:00-05:00</published><updated>2020-03-23T00:00:00-05:00</updated><id>https://openml.github.io/blog/openml/data/2020/03/23/Finding%20a-standard-dataset-format-for-machine-learning</id><content type="html" xml:base="https://openml.github.io/blog/openml/data/2020/03/23/Finding-a-standard-dataset-format-for-machine-learning.html">&lt;p&gt;With OpenML, we aim to take a worry-free, 'zen'-like approach to working with machine learning datasets, making them easy and reliable to use. We want to offer training data that can be easily (or automatically) used. As such, you can now load any dataset and start building models without any manual intervention. For historical reasons, we have done this by internally storing all data in the &lt;a href=&quot;https://www.cs.waikato.ac.nz/ml/weka/arff.html&quot;&gt;ARFF&lt;/a&gt; data format, which is a simple single-table format, including meta-data such as the correct feature data types.&lt;/p&gt;

&lt;p&gt;However, this format is currently holding us back: it is not ideal for storing large datasets, the format is only loosely defined causing different parsers to behave differentlyeDd, and many new machine learning tasks require multi-table data. For instance, image segmentation or object detection tasks have both images and varying amounts of annotations per image.&lt;/p&gt;

&lt;p&gt;Hence, we started searching for a better data format that we can use to store (and share) machine learning datasets in the foreseeable future. This blog post presents out process and insights. We would love to hear your thoughts and experiences before we make any decision on how to move forward.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Scope&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We first defined the general scope of the usage of the format:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We mainly need a format that is &lt;strong&gt;useful for data storage and transmission&lt;/strong&gt;. We can always convert data during upload or download in OpenML's client APIs. For instance, people may upload a Python pandas dataframe to OpenML, and later get the same dataframe back, without realizing or caring how the data was stored in the meantime. If people want to store the data locally, they can download it in the format they like (e.g. a memory-mapped format like Arrow/Feather for fast reading or TFRecords for people using TensorFlow). Additional code can facilitate such conversions.&lt;/li&gt;
  &lt;li&gt;The format should &lt;strong&gt;allow storing most machine learning datasets,&lt;/strong&gt; including images, video, audio, text, graphs, and multi-tabular data such as object recognition tasks and relational data.&lt;/li&gt;
  &lt;li&gt;To make the data easy to use, there should be a &lt;strong&gt;standard way to represent specific types of data&lt;/strong&gt; (i.e. a fixed schema that can be verified), so that we can easily read and store datasets in a uniform way. For instance, all tabular data should be stored in a uniform way.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Impact on OpenML (simplicity, maintenance)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since OpenML is a community project, we want to keep it as easy as possible to use and maintain:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We prefer a &lt;strong&gt;single internal data format&lt;/strong&gt; rather than multiple ones, since the latter would impose more maintenance on both server-side and client-side.&lt;/li&gt;
  &lt;li&gt;Even if we choose a flexible data format, &lt;strong&gt;this does not mean that we will store arbitrary dataset files&lt;/strong&gt; for which we cannot guarantee data quality and easy of use.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;We will require machine-readable schemas&lt;/strong&gt;(in a specific language) that describe how a certain 'type' data is formatted, to ensure ease of use and maintainability. Examples would be a schema for tabular data, a schema for annotated image data, etc. Every dataset should specify the schema it satisfied. We should be able to &lt;strong&gt;validate&lt;/strong&gt; whether the dataset indeed satisfies the schema. &lt;strong&gt;Every OpenML task should be mapped to a schema, so that it is clear how the data must be used in training and testing&lt;/strong&gt;. OpenML's clients can then use these schema to handle new types of data.&lt;/li&gt;
  &lt;li&gt;OpenML would have a set of &lt;strong&gt;allowed schemas&lt;/strong&gt;. We will stick to tabular data until other schemas are defined, and we are sure that we can validate and handle those datasets.&lt;/li&gt;
  &lt;li&gt;When no agreed upon schema exists, we could offer a forum for the community to discuss and agree on a standard schema, in collaboration with other initiatives (e.g. &lt;a href=&quot;https://frictionlessdata.io/&quot;&gt;frictionlessdata&lt;/a&gt;). [For instance, new schemas could be created in a github repo to allow people to do create pull requests. They could be effectively used once they are merged.]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Requirements&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To draw up a shortlist of data formats, we used the following requirements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Maintenance. We are still a small community so we would prefer a format which is stable and fully maintained over something which we would have to maintain ourselves.&lt;/li&gt;
  &lt;li&gt;Support for the format in various programming languages, including well-maintained and stable libraries.&lt;/li&gt;
  &lt;li&gt;Support for reading the data without copying everything into memory (e.g. incremental reads/writes), and for subselecting parts of the data and operating only on that.&lt;/li&gt;
  &lt;li&gt;Ideally, there is a way to detect bitflip errors during storage or transmission.&lt;/li&gt;
  &lt;li&gt;The dataset format should support multiple &quot;resources&quot; to support cases when we would like to store collections of files or multiple relational tables.&lt;/li&gt;
  &lt;li&gt;Support for storing binary blobs and vectors of different lengths.&lt;/li&gt;
  &lt;li&gt;Anything else being equal, the dataset format should be compact.&lt;/li&gt;
  &lt;li&gt;Ideally, there should be support for storing sparse data.&lt;/li&gt;
  &lt;li&gt;A nice to have is that we can store some meta-data inside the file. OpenML can generate more extensive meta-data on the fly, but storing a minimal set inside the file may be useful.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Shortlist&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We decided to investigate the following formats in more detail:&lt;/p&gt;

&lt;p&gt;Apache &lt;a href=&quot;https://arrow.apache.org/&quot;&gt;&lt;strong&gt;Arrow&lt;/strong&gt;&lt;/a&gt; &lt;strong&gt;/&lt;/strong&gt; &lt;a href=&quot;https://github.com/wesm/feather&quot;&gt;&lt;strong&gt;Feather&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Benefits:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Great for locally caching files after download&lt;/li&gt;
  &lt;li&gt;Memory-mapped, so very fast reads&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Drawbacks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Not stable enough yet and not ideal for long-term storage. The authors also discourage it for long-term storage.&lt;/li&gt;
  &lt;li&gt;Limited to one data structure per file, but that data structure can be complex (e.g. dict).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://parquet.apache.org/&quot;&gt;&lt;strong&gt;Parquet&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Benefits:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Used in industry a lot, especially in combination with Apache Spark. Good community of practice&lt;/li&gt;
  &lt;li&gt;Well-supported and maintained, but not all Parquet features are supported in every library. E.g. the python library does not support partial read/writes.&lt;/li&gt;
  &lt;li&gt;Simple structure&lt;/li&gt;
  &lt;li&gt;Built-in compression (columnar storage), very efficient long-term data storage&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Drawbacks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The different parsers (e.g. &lt;a href=&quot;https://arrow.apache.org/docs/python/parquet.html&quot;&gt;Parquet support inside Arrow&lt;/a&gt;, &lt;a href=&quot;https://fastparquet.readthedocs.io/&quot;&gt;fastparquet&lt;/a&gt;) implement different parts of the Parquet format (and different set of compression algorithms), meaning that the output may not be &lt;a href=&quot;https://fastparquet.readthedocs.io/en/latest/#caveats-known-issues&quot;&gt;compatible&lt;/a&gt;&lt;a href=&quot;https://kb.databricks.com/data/wrong-schema-in-files.html&quot;&gt;with&lt;/a&gt; other parsers (in other languages).&lt;/li&gt;
  &lt;li&gt;Support limited to single-table storage. There is good support to convert to and from pandas DataFrames, but there is less support for more complex data structures. Also, Parquet files created by other libraries might not be readable into pandas. More complicated data schemas might be possible, but are not supported in Python. For instance, there doesn't seem to be an apparent way to store an object detection dataset (with images and annotations) as a single parquet file.&lt;/li&gt;
  &lt;li&gt;Limited support for incremental reading/writing. None of the parsers we looked at (e.g. &lt;a href=&quot;https://arrow.apache.org/docs/python/parquet.html&quot;&gt;Parquet support inside Arrow&lt;/a&gt;, &lt;a href=&quot;https://fastparquet.readthedocs.io/&quot;&gt;fastparquet&lt;/a&gt;) allows incremental writes, which may be an issue for large datasets when we (or end users) cannot load the data into memory. We can easily store large datasets in multiple (partitioned) parquet files, but that would make them less easy to use in OpenML.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.sqlite.org/index.html&quot;&gt;&lt;strong&gt;SQLite&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Benefits:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SQLite was the easiest to use. It was comparably fast to HDF5 in our tests.&lt;/li&gt;
  &lt;li&gt;Very good support in all languages. For instance, it is &lt;a href=&quot;https://docs.python.org/3.7/library/sqlite3.html&quot;&gt;built-in&lt;/a&gt; in Python.&lt;/li&gt;
  &lt;li&gt;Very flexible access to parts of the data. SQL queries can be used to select any subset of the data.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Drawback:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It supports only 2000 columns, and we have quite a few datasets with more than 2000 features. Hence, storing large tabular data will require mapping data differently, which would add a lot of additional complexity.&lt;/li&gt;
  &lt;li&gt;Writing SQL queries requires knowledge of the internal data structure (tables, keys,…).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.hdfgroup.org/solutions/hdf5/&quot;&gt;&lt;strong&gt;HDF5&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Benefits:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Very good support in all languages. Has well-tested parsers, all using the same C implementation.&lt;/li&gt;
  &lt;li&gt;Widely accepted format in the deep learning community to store data and models.&lt;/li&gt;
  &lt;li&gt;Widely accepted format in many scientific domains (e.g. astronomy, bioinformatics,…)&lt;/li&gt;
  &lt;li&gt;Provides built-in compression. Constructing and loading datasets was reasonably fast.&lt;/li&gt;
  &lt;li&gt;Very flexible. Should allow to store any machine learning dataset as a single file.&lt;/li&gt;
  &lt;li&gt;Allows easy inclusion of meta-data inside the file, creating a self-contained file.&lt;/li&gt;
  &lt;li&gt;Self-descriptive: the structure of the data can be easily read programmatically. For instance, 'h5dump -H -A 0 mydata.hdf5' will give you a lot of detail on the structure of the dataset.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Drawbacks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Complexity. We cannot make any a priori assumptions about how the data is structured. We need to define schema and implement code that automatically validates that a dataset follows a specific schema (e.g. e.g. using h5dump to see whether it holds a single dataframe that we could load into pandas).&lt;/li&gt;
  &lt;li&gt;The format has a very long and detailed specification. While parsers exist we don't really know whether they are fully compatible with each other. There may be unknown bugs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CSV&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Benefits:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Very good support in all languages.&lt;/li&gt;
  &lt;li&gt;Easy to use, requires very little additional tooling&lt;/li&gt;
  &lt;li&gt;Easy versioning with git LFS. Changes in different versions can be observed with a simple git diff.&lt;/li&gt;
  &lt;li&gt;The current standard used in &lt;a href=&quot;https://frictionlessdata.io/&quot;&gt;frictionlessdata&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;There exist schema to express certain types of data in CSV (see &lt;a href=&quot;https://frictionlessdata.io/&quot;&gt;frictionlessdata&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Drawbacks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Not very efficient for storing floating point numbers&lt;/li&gt;
  &lt;li&gt;Not ideal for very, very large datasets (when data does not fit in memory/disk)&lt;/li&gt;
  &lt;li&gt;Many different dialects exist. We need to decide on a standardized dialect and enforce that only that dialect is used on OpenML (&lt;a href=&quot;https://frictionlessdata.io/specs/csv-dialect/&quot;&gt;https://frictionlessdata.io/specs/csv-dialect/&lt;/a&gt;). The dialect specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc4180&quot;&gt;RFC4180&lt;/a&gt;, which uses the comma as delimiter and the quotation mark as quote character, is often recommended.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Overview&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Parquet&lt;/th&gt;
      &lt;th&gt;HDF5&lt;/th&gt;
      &lt;th&gt;SQLite&lt;/th&gt;
      &lt;th&gt;CSV&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Consistency across different platforms&lt;/td&gt;
      &lt;td&gt;Check or clarify&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;✅(dialect)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Support and documentation&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Supports very large and high-dimensional datasets&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;❌(limited nr. columns per table)&lt;/td&gt;
      &lt;td&gt;✅ Storing tensors requires flattening.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Simplicity&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;❌(basically full file system)&lt;/td&gt;
      &lt;td&gt;✅(database)&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Metadata support&lt;/td&gt;
      &lt;td&gt;Only minimal&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;❌(requires separate metadata file)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Maintenance&lt;/td&gt;
      &lt;td&gt;Apache project, open and quite &lt;a href=&quot;https://www.slideshare.net/Hadoop_Summit/the-columnar-roadmap-apache-parquet-and-apache-arrow-102997214&quot;&gt;active&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Closed group, but &lt;a href=&quot;https://www.slideshare.net/HDFEOS/hdf5-roadmap-20192020&quot;&gt;active&lt;/a&gt; community on Jira and conferences&lt;/td&gt;
      &lt;td&gt;Run by a &lt;a href=&quot;https://www.sqlite.org/prosupport.html&quot;&gt;company&lt;/a&gt;. Community interaction via email list.&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Available examples of usage in ML&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;❌&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Allows incremental reads/writes&lt;/td&gt;
      &lt;td&gt;Yes, but not supported by current Python libs&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;✅&lt;/td&gt;
      &lt;td&gt;Yes (but not random access)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Flexibility&lt;/td&gt;
      &lt;td&gt;Only tabular data supported&lt;/td&gt;
      &lt;td&gt;Very flexible, maybe too flexible&lt;/td&gt;
      &lt;td&gt;Relational multi-table&lt;/td&gt;
      &lt;td&gt;Only tabular&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Performance benchmarks&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;There exist some prior benchmarks (&lt;a href=&quot;https://tech.jda.com/efficient-dataframe-storage-with-apache-parquet/&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://towardsdatascience.com/the-best-format-to-save-pandas-data-414dca023e0d&quot;&gt;here&lt;/a&gt;) on storing dataframes. These only consider single-table datasets. We also ran our own &lt;a href=&quot;https://gitlab.com/mitar/benchmark-dataset-formats&quot;&gt;benchmark&lt;/a&gt; to compare the writing performance of those data formats for more complex machine learning datasets, such as pedestrian detection and music analysis (note that we could not find a way to store these in one file in Parquet). Reading benchmarks have yet to be done.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Version control&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Version control for large datasets is tricky. For CSV, we could use &lt;a href=&quot;https://git-lfs.github.com/&quot;&gt;git LFS&lt;/a&gt; store the datasets and have automated versioning of datasets. The binary formats do not allow us to track changes in the data, only to recover the exact versions of the datasets you want (and their metadata).&lt;/p&gt;

&lt;p&gt;We found it quite easy to export all OpenML dataset to GitLab: &lt;a href=&quot;https://gitlab.com/data/d/openml&quot;&gt;https://gitlab.com/data/d/openml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We need your help!&lt;/strong&gt;
If we have missed any format we should investigate, or misunderstood those we have investigated, or missed some best practice, please tell us.&lt;/p&gt;

&lt;p&gt;Email: openmlhq@googlegroups.com&lt;/p&gt;

&lt;p&gt;React via github: https://github.com/openml/openml-data/issues/29&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Contributors to this blog post:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mitar Milutinovic, Prabhant Singh, Joaquin Vanschoren, Pieter Gijsbers&lt;/p&gt;</content><author><name>Pieter Gijsbers, Mitar Milutinovic, Prabhant Singh, Joaquin Vanschoren</name></author><summary type="html">With OpenML, we aim to take a worry-free, 'zen'-like approach to working with machine learning datasets, making them easy and reliable to use. We want to offer training data that can be easily (or automatically) used. As such, you can now load any dataset and start building models without any manual intervention. For historical reasons, we have done this by internally storing all data in the ARFF data format, which is a simple single-table format, including meta-data such as the correct feature data types.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://openml.github.io/blog/images/fastpages_posts/format.jpg" /><media:content medium="image" url="https://openml.github.io/blog/images/fastpages_posts/format.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>